Министерство науки и высшего образования Российской Федерации федеральное государственное автономное образовательное учреждение высшего образования

«Национальный исследовательский университет ИТМО»

---
__ФПИиКТ, Системное и Прикладное Программное Обеспечение__

__Лабораторная работа №1__

по Функциональному программированию

Выполнил: Ханнанов Л. И.

Группа: P34112

Преподаватель: Пенской Александр Владимирович

###### Санкт-Петербург
###### 2022 г.

---

## Описание проблемы
### [Even Fibonacci numbers](https://projecteuler.net/problem=2)

#### Problem 2

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

$$
  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
$$

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

### [Distinct powers](https://projecteuler.net/problem=29)

#### Problem 29

Consider all integer combinations of $a^b$ for $2 \leq a \leq 5$ and $2 \leq b \leq 5$:

$$
  \begin{align*}
    2^2=4, && 2^3=8,  && 2^4=16, && 2^5=32\\
    3^2=9, && 3^3=27, && 3^4=81, && 3^5=243\\
    4^2=16,&& 4^3=64, && 4^4=256,&& 4^5=1024\\
    5^2=25,&& 5^3=125,&& 5^4=625,&& 5^5=3125
  \end{align*}
$$

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

$$
  4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
$$

How many distinct terms are in the sequence generated by $a^b$ for $2 \leq a \leq 100$ and $2 \leq b \leq 100$?

## Ключевые элементы реализации с минимальными комментариями

### Problem 2

1. __монолитная реализация__
    + __хвостовая рекурсия__
    ```
    (define (sum-of-even-fibonacci-numbers-less-than limit)
      (cond
        [(negative? limit) (raise-argument-error 'negative-limit "non-negative value" limit)]
        [else
        (let inner-summer ([sum 0] [previous 1] [current 1])
          (if (= limit 0)
              0
              (if (not (negative? (- current limit)))
                  sum
                  (if (even? current)
                      (inner-summer (+ sum current) current (+ previous current))
                      (inner-summer sum current (+ previous current))))))]))

    (sum-of-even-fibonacci-numbers-less-than 4000000)
    ```
    В параметрах вспомогательной функции указывается предыдущее число фибоначчи, текущее число и сумма, и рекурсивно сумма накапливается только текущими числами, если они четны.

    + __рекурсия__
    ```racket
    (define (sum-of-even-fibonacci-numbers-less-than limit)
      (cond
        [(> limit 1)
        (let ([closest-number (let closest-fibonacci-number ([previous 1] [current 1])
                                (if (>= current limit)
                                    previous
                                    (closest-fibonacci-number current (+ previous current))))])
          (if (even? closest-number)
              (+ closest-number (sum-of-even-fibonacci-numbers-less-than closest-number))
              (sum-of-even-fibonacci-numbers-less-than closest-number)))]
        [(= limit 1) 0]
        [(zero? limit) 0]
        [else (raise-argument-error 'negative-limit "non-negative value" limit)]))

    (sum-of-even-fibonacci-numbers-less-than 4000000)
    ```
    Ясно, что если `limit` меньше 1, то сумма нулевая, так как чисел нет никаких, для большей величины лимита, мы находим ближайшее число фибоначчи и складываем с вызовом нашей функции лимитом меньше чем найденное число, если это найденное число четно.

2. __модульная реализация__
```
(define (fibonacci-numbers-less-than limit)
  (let loop ([previous 1] [current 1])
    (if (>= current limit)
      (list)
      (list* current (loop current (+ previous current))))))

(foldl + 0 (filter even? (fibonacci-numbers-less-than 4000000)))
```
Генерируем по формуле список чисел фибоначчи без разбору, пока не дойдем до лимита, затем, используя функции `filter` и `foldl` отсеиваем нечетные и сворачиваем в сумму.

3. __генерация последовательности при помощи отображения (map)__
```
(define (fibonacci n)
  (if (<= n 2) n (+ (fibonacci (sub1 n)) (fibonacci (- n 2)))))

(define (last-fibonacci-number-less-than limit previous current number)
  (if (>= current limit)
      (sub1 number)
      (last-fibonacci-number-less-than limit current (+ previous current) (add1 number))))

(foldl +
       0
       (map (lambda (number) (if (even? number)
                                  number
                                  0))
            (map fibonacci
                 (sequence->list
                  (in-inclusive-range 1 (last-fibonacci-number-less-than 4000000 1 1 1))))))
```
Находим номер числа фибоначчи близкого к лимиту и генерируем последовательность чисел от одного до найденного номера, затем с помощью map преобразуем их в соответствующие числа фибоначчи, и также как в предыдущем решении сворачиваем с помощью `foldl`.

4. __работа со спец. синтаксисом для циклов__
```
(define (sum-of-even-fibonacci-numbers-less-than limit)
  (do ([sum 0] [previous 1 current] [current 1 (+ previous current)])
      ((>= current limit) sum)
      (if (even? current)
        (set! sum (+ current sum))
        (void))))

(sum-of-even-fibonacci-numbers-less-than 4000000)
```
Циклом `do` накапливаем сумму по формуле, складываем только четные числа фибоначчи. Второе выражение это условие `break`.

5. __работа с бесконечными списками для языков поддерживающих ленивые коллекции или итераторы как часть языка__
```
(define (even-fibonacci-numbers-less-than limit)
  (let loop ([previous 1] [current 1])
    (if (>= current limit)
        empty-stream
        (if (even? current)
            (stream* current (loop current (+ previous current)))
            (loop current (+ previous current))))))

(stream-fold + 0 (even-fibonacci-numbers-less-than 4000000))
```
Рекурсивно насаживаем только четные числа фибоначчи на стрим. Затем сворачиваем с помощью функции для стримов, которая аналогична спискам. Весь стрим вычисляется только в момент вызова `stream-fold`.

6. __реализация на любом удобном языке программировании__
```
def fibonacci_less_than(limit: int) -> Iterable[int]:
    prev = 0
    curr = 1
    while curr < limit:
        temp = curr
        curr = prev + curr
        prev = temp
        if curr >= limit:
            break
        yield curr


def main(limit: int) -> None:
    print(sum(filter(lambda x: x % 2 == 0, fibonacci_less_than(limit))))
```
Функция вернет генератор, в котором все числа фибоначчи до заданного лимита. А функции `filter` и `sum` соответственно отсеют нечетные и найдут сумму оставшихся чисел.

### Problem 29

1. __монолитная реализация__
    + __хвостовая рекурсия__
    ```
    (define (loop-a limit a b unique)
      (if (> a limit) unique (loop-a limit (add1 a) b (set-add unique (expt a b)))))

    (define (loop-b high-limit lower-limit b unique)
      (if (> b high-limit)
          unique
          (loop-b
            high-limit
            lower-limit
            (add1 b)
            (loop-a high-limit lower-limit b unique))))

    (define (distinct-powers left right)
      (if (< right left)
          (raise (make-exn:fail:contract "Invalid parameters passed"))
          (set-count (loop-b right left left (set)))))

    (distinct-powers 2 100)
    ```
    В параметрах `a` и `b` `loop-a` и `loop-b` указываются счетчики циклов. А в параметре `unique` собирается результирующее множество чисел $a^b$ путем объединения с уже полученными множествами на предыдущих итерациях. Затем находим мощность множества с помощью `set-count`.

    + __рекурсия__
    ```
    (define (inner-loop init limit b)
      (define a init)
      (if (= a limit)
        (set (expt a b))
        (set-add (inner-loop (add1 a) limit b) (expt a b))))

    (define (external-loop init-b init-a limit-b limit-a)
      (define b init-b)
      (if (= b limit-b)
          (inner-loop init-a limit-a b)
          (set-union
            (external-loop (add1 b) init-a limit-b limit-a)
            (inner-loop init-a limit-a b))))

    (define (distinct-powers left right)
      (if (negative? right)
          (raise (make-exn:fail:contract "Invalid right value passed"))
          (set-count (external-loop left left right right))))

    (distinct-powers 2 100)
    ```
    Рекурсивная реализация строит множество с помощью двух функций, одна для внешнего цикла – степени числа, другая для вложенного цикла – основания. У результирующего множества находим затем его мощность.

2. __модульная реализация__
```
(define (distinct-powers left right)
  (foldl +
         0
         (map (lambda (n) (quotient n n))
              (remove-duplicates
                (let ([powers (build-list (add1 (- right left))
                                                           (lambda (n) (+ n left)))])
                                   (for*/list ([a powers] [b powers])
                                     (expt a b)))))))

(distinct-powers 2 100)
```
Во вложенном цикле собираем список из всевозможных комбинаций `a` и `b`. Убираем повторения и с помощью `(quotient n n)` заменяем все числа на `1`, сумма этих единиц и даст длину списка, что является ответом на задачу.

3. __генерация последовательности при помощи отображения (map)__
```
(define (distinct-powers left right)
  (foldl +
         0
         (map (lambda (n) (quotient n n))
              (remove-duplicates
                (append* (let ([powers (inclusive-range left right)])
                                            (for/list ([a powers])
                                              (map (lambda (n) (expt n a)) powers))))))))

(distinct-powers 2 100)
```
С помощью самого внутреннего вызова map мы формируем получаем список чисел вида $a^n$, где `n` меняется от `2` до `100` в цикле `for/list`, и все полученные списки организуются в один список, получаются списки в списке, который приводим к одномерному списку с помощью формы `append*`. Следующий `map` нужен, чтобы заменить все уникальные числа вида $a^b$ на `1`, хитрый вызов `(quotient n n)` нужен только, чтобы линтер не ругался, что в лямбде не используется параметр `n`. И полученный список из `1`, сворачиваем в сумму, что и будет длиной этого списка и ответом на задачу.

4. __работа со спец. синтаксисом для циклов__
```
(define (distinct-powers left right)
  (for/fold ([length 0])
            ([distinct-power
              (for/fold ([acc '()])
                        ([a-b (let ([powers (build-list (add1 (- right left))
                                                        (lambda (n) (+ n left)))])
                                (for*/list ([a powers] [b powers])
                                  (expt a b)))])
                (if (= (length (filter (lambda (x) (equal? x a-b)) acc)) 0)
                  (list* a-b acc)
                  acc))])
    (if (number? distinct-power)
        (add1 length)
        (raise-argument-error 'incorrect-type "number?" distinct-power))))

(distinct-powers 2 100)
```
Специальный цикл `for*/list` позволяет пройтись по всем комбинациям поданных итерируемых коллекциях и собрать все это в единый список. Затем с помощью цикла `for/fold` мы собираем это в еще один список, убрав все повторения путем того, что мы в нашем собираемом списке проверяем, есть ли уже данный элемент. И только затем, с помощью еще одного цикла `for/fold`, мы получаем количество чисел в полученном множестве.

5. __работа с бесконечными списками для языков поддерживающих ленивые коллекции или итераторы как часть языка__
```
(define (distinct-powers left right)
  (stream-length (for/stream ([i
                               (remove-duplicates
                                (let ([powers (in-inclusive-range left right)])
                                  (stream->list (for*/stream ([a powers] [b powers]) (expt a b)))))])
                             i)))

(distinct-powers 2 100)
```
С помощью `for*/stream` организуется вложенный цикл по всем комбинациям `a` и `b`, которые затем собираются в стрим, который преобразуется в список, из которого мы убираем повторения, затем снова собираем список в стрим и находим его длину. Моя попытка решения с использованием только стримов и собственной функции удаления повторений приводила к слишком долгим вычислениям в частности из-за ленивости стримов, который вычислялся только в конце, когда вызывалась функция `stream-length`.

6. __реализация на любом удобном языке программировании__
```
def distinct_powers(a_bounds: Tuple[int, int] = (0, 0),
        b_bounds: Tuple[int, int] = (0, 0)) -> Set[int]:
    a_left, a_right = a_bounds
    b_left, b_right = b_bounds
    result = set()
    for base_a in range(a_left, a_right + 1):
        for exponent_b in range(b_left, b_right + 1):
            result.add(base_a**exponent_b)
    return result


def main():
    bounds = (2, 100)
    print(len(distinct_powers(bounds, bounds)))
```
Решение в лоб. Во вложенном цикле добавляем $a^b$ в множество, тем самым получаем множество чисел без повторений и просто берем его мощность.

## Выводы

В ходе выполнения данной лабораторной работы я освоил базовые приемы и абстракции языка __Racket__. Рекурсия, функции свертки, отображения и другие потоковые функции, списки, последовательности и стримы. Формы передачи потока управления в виде различных циклов, условных форм `if` и `cond`. Формы для организации локальных привязок с помощью `let`.
